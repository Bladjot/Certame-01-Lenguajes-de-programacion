# 🥋 Intérprete del Lenguaje de Luchadores

Este proyecto implementa un **lenguaje de programación personalizado** para definir luchadores, sus movimientos y simular combates entre ellos.  
Fue desarrollado en **Python** utilizando **Flex y Bison a través de la librería PLY (Python Lex-Yacc)**.

---

## 🧠 Objetivo

El propósito es crear un lenguaje con **dos fases principales**:

1. **Definición de luchadores:**  
   Permite declarar luchadores con sus estadísticas, acciones básicas (puños, patadas, bloqueos) y combos.

2. **Simulación del combate:**  
   Permite establecer enfrentamientos entre luchadores, reglas de turno, condiciones (`si/sino`), y duración del combate.

---

## ⚙️ Tecnologías utilizadas

- **Python 3.10+**
- **PLY (Python Lex-Yacc)** — para el análisis léxico y sintáctico
- **Programación modular** (separación en lexer, parser, intérprete y entrada principal)

Instalación de PLY:
```bash
pip install ply
📁 Estructura del proyecto
bash
Copiar código
proyecto_luchadores/
│
├── lexer/
│   └── tokens.py               # Analizador léxico (equivalente a Flex)
│
├── parser/
│   ├── gramatica.py            # Clases base: Luchador, Accion, Combo, Condicion, etc.
│   └── interprete.py           # Gramática + ejecución del combate (equivalente a Bison)
│
├── main/
│   └── main.py                 # Punto de entrada del programa
│
└── ejemplos/
    └── programa.txt            # Archivo de entrada con el código del lenguaje
💬 Ejemplo de código fuente (programa.txt)
txt
Copiar código
luchador Ryu {
  stats(hp=100, st=100);
  acciones {
    golpe: puño_fuerte(daño=10, costo=7, altura=media, forma=frontal, giratoria=no);
    patada: patada_baja(daño=6, costo=4, altura=baja, forma=frontal, giratoria=no);
    bloqueo: bloqueo_alto;
  }
  combos {
    Hadouken(st_req=20) { puño_fuerte, patada_baja }
  }
}

luchador Ken {
  stats(hp=100, st=100);
  acciones {
    golpe: puño_fuerte(daño=10, costo=7, altura=media, forma=frontal, giratoria=no);
    patada: patada_baja(daño=6, costo=4, altura=baja, forma=frontal, giratoria=no);
  }
}

simulacion {
  config {
    luchadores: Ryu vs Ken;
    inicia: Ryu;
    turnos_max: 5;
  }
  pelea {
    turno Ryu {
      si (oponente.hp < 50) { usa Hadouken; }
      sino { usa puño_fuerte; }
      usa patada_baja;
    }
    turno Ken {
      usa puño_fuerte;
      si (self.st > 40) { usa Hadouken; }
      sino { usa patada_baja; }
    }
  }
}
🚀 Ejecución
Coloca el archivo programa.txt dentro de la carpeta ejemplos/.

Abre una terminal en la carpeta main/.

Ejecuta el programa:

bash
Copiar código
python main.py
Verás el desarrollo del combate paso a paso, junto con el resultado final.

🧩 Funcionamiento interno
El proyecto se basa en los principios de compiladores, dividiéndose en tres etapas:

1️⃣ Análisis léxico (lexer/tokens.py)
Define las expresiones regulares que identifican los tokens (palabras clave, identificadores, números, símbolos, operadores).

Cada token se define con una variable t_TOKEN o una función t_nombre().

Se encarga de ignorar comentarios y espacios y manejar errores léxicos.

2️⃣ Análisis sintáctico (parser/interprete.py)
Implementa la gramática libre de contexto (GLC) con PLY, equivalente a las producciones de Bison.

Cada regla se define como una función con el formato:

python
Copiar código
def p_nombre(p):
    """nombre : simbolo simbolo simbolo"""
    p[0] = Resultado
Por ejemplo:

python
Copiar código
def p_instruccion(p):
    """instruccion : USA ID PUNTO_Y_COMA
                   | SI PAREN_ABRE condicion PAREN_CIERRA LLAVE_ABRE lista_instrucciones LLAVE_CIERRA
                   | SI PAREN_ABRE condicion PAREN_CIERRA LLAVE_ABRE lista_instrucciones LLAVE_CIERRA SINO LLAVE_ABRE lista_instrucciones LLAVE_CIERRA"""
🔹 Cada línea dentro del docstring """ ... """ define una producción posible para esa regla.
Por ejemplo:

usa puño_fuerte;

si (self.st > 50) { usa golpe; }

si (...) { ... } sino { ... }

🔹 El parámetro p funciona como una lista de símbolos, donde:

p[0] es el resultado (lo que se devuelve a la regla superior),

p[1], p[2], etc. son los elementos reconocidos (tokens o subreglas).

Ejemplo:

python
Copiar código
if len(p) == 4:
    p[0] = Usar(p[2])  # Construye un objeto de tipo Usar()
elif len(p) == 8:
    p[0] = SiSino(p[3], p[6], [])  # Condicional simple
else:
    p[0] = SiSino(p[3], p[6], p[10])  # Condicional con "sino"
3️⃣ Ejecución del combate
Se crean objetos de las clases definidas en gramatica.py (Luchador, Combo, Condición, etc.).

El intérprete recorre la simulación, turno por turno:

Aplica acciones (usa <acción>).

Evalúa condiciones (si/sino).

Controla la energía (ST) y los puntos de vida (HP).

Aplica las reglas de fallo de combo (si no hay ST suficiente, se usa la primera acción del combo).

🧩 Árbol sintáctico simplificado
Para la instrucción:

txt
Copiar código
si (oponente.hp < 50) {
    usa Hadouken;
} sino {
    usa puño_fuerte;
}
El parser genera internamente:

less
Copiar código
SiSino(
  condicion = (oponente.hp < 50),
  bloque_si = [Usar("Hadouken")],
  bloque_sino = [Usar("puño_fuerte")]
)
🏁 Resultado del combate (ejemplo)
yaml
Copiar código
⚔️  COMBATE: Ryu vs Ken
Turnos máximos: 5

➡️  Turno 1 de Ryu:
🥊 Ryu usa puño_fuerte (-10 HP al rival)
🥊 Ryu usa patada_baja (-6 HP al rival)

➡️  Turno 1 de Ken:
🥊 Ken usa puño_fuerte (-10 HP al rival)
💥 Ken ejecuta combo Hadouken
🥊 Ken usa puño_fuerte (-10 HP al rival)
🥊 Ken usa patada_baja (-6 HP al rival)

🏁 RESULTADO FINAL:
Ryu: HP=74, ST=83
Ken: HP=84, ST=73
🔥 Gana Ken
🧾 Conclusión
Este intérprete muestra el flujo completo de un mini lenguaje imperativo, desde el análisis léxico hasta la ejecución.
Permite comprender de forma práctica cómo funcionan:

Las gramáticas libres de contexto,

Las estructuras condicionales simples,

Y la traducción de reglas sintácticas en objetos ejecutables.