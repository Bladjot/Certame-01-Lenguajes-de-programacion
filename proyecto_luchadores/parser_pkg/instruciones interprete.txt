# ğŸ¥‹ IntÃ©rprete del Lenguaje de Luchadores

Este proyecto implementa un **lenguaje de programaciÃ³n personalizado** para definir luchadores, sus movimientos y simular combates entre ellos.  
Fue desarrollado en **Python** utilizando **Flex y Bison a travÃ©s de la librerÃ­a PLY (Python Lex-Yacc)**.

---

## ğŸ§  Objetivo

El propÃ³sito es crear un lenguaje con **dos fases principales**:

1. **DefiniciÃ³n de luchadores:**  
   Permite declarar luchadores con sus estadÃ­sticas, acciones bÃ¡sicas (puÃ±os, patadas, bloqueos) y combos.

2. **SimulaciÃ³n del combate:**  
   Permite establecer enfrentamientos entre luchadores, reglas de turno, condiciones (`si/sino`), y duraciÃ³n del combate.

---

## âš™ï¸ TecnologÃ­as utilizadas

- **Python 3.10+**
- **PLY (Python Lex-Yacc)** â€” para el anÃ¡lisis lÃ©xico y sintÃ¡ctico
- **ProgramaciÃ³n modular** (separaciÃ³n en lexer, parser, intÃ©rprete y entrada principal)

InstalaciÃ³n de PLY:
```bash
pip install ply
ğŸ“ Estructura del proyecto
bash
Copiar cÃ³digo
proyecto_luchadores/
â”‚
â”œâ”€â”€ lexer/
â”‚   â””â”€â”€ tokens.py               # Analizador lÃ©xico (equivalente a Flex)
â”‚
â”œâ”€â”€ parser/
â”‚   â”œâ”€â”€ gramatica.py            # Clases base: Luchador, Accion, Combo, Condicion, etc.
â”‚   â””â”€â”€ interprete.py           # GramÃ¡tica + ejecuciÃ³n del combate (equivalente a Bison)
â”‚
â”œâ”€â”€ main/
â”‚   â””â”€â”€ main.py                 # Punto de entrada del programa
â”‚
â””â”€â”€ ejemplos/
    â””â”€â”€ programa.txt            # Archivo de entrada con el cÃ³digo del lenguaje
ğŸ’¬ Ejemplo de cÃ³digo fuente (programa.txt)
txt
Copiar cÃ³digo
luchador Ryu {
  stats(hp=100, st=100);
  acciones {
    golpe: puÃ±o_fuerte(daÃ±o=10, costo=7, altura=media, forma=frontal, giratoria=no);
    patada: patada_baja(daÃ±o=6, costo=4, altura=baja, forma=frontal, giratoria=no);
    bloqueo: bloqueo_alto;
  }
  combos {
    Hadouken(st_req=20) { puÃ±o_fuerte, patada_baja }
  }
}

luchador Ken {
  stats(hp=100, st=100);
  acciones {
    golpe: puÃ±o_fuerte(daÃ±o=10, costo=7, altura=media, forma=frontal, giratoria=no);
    patada: patada_baja(daÃ±o=6, costo=4, altura=baja, forma=frontal, giratoria=no);
  }
}

simulacion {
  config {
    luchadores: Ryu vs Ken;
    inicia: Ryu;
    turnos_max: 5;
  }
  pelea {
    turno Ryu {
      si (oponente.hp < 50) { usa Hadouken; }
      sino { usa puÃ±o_fuerte; }
      usa patada_baja;
    }
    turno Ken {
      usa puÃ±o_fuerte;
      si (self.st > 40) { usa Hadouken; }
      sino { usa patada_baja; }
    }
  }
}
ğŸš€ EjecuciÃ³n
Coloca el archivo programa.txt dentro de la carpeta ejemplos/.

Abre una terminal en la carpeta main/.

Ejecuta el programa:

bash
Copiar cÃ³digo
python main.py
VerÃ¡s el desarrollo del combate paso a paso, junto con el resultado final.

ğŸ§© Funcionamiento interno
El proyecto se basa en los principios de compiladores, dividiÃ©ndose en tres etapas:

1ï¸âƒ£ AnÃ¡lisis lÃ©xico (lexer/tokens.py)
Define las expresiones regulares que identifican los tokens (palabras clave, identificadores, nÃºmeros, sÃ­mbolos, operadores).

Cada token se define con una variable t_TOKEN o una funciÃ³n t_nombre().

Se encarga de ignorar comentarios y espacios y manejar errores lÃ©xicos.

2ï¸âƒ£ AnÃ¡lisis sintÃ¡ctico (parser/interprete.py)
Implementa la gramÃ¡tica libre de contexto (GLC) con PLY, equivalente a las producciones de Bison.

Cada regla se define como una funciÃ³n con el formato:

python
Copiar cÃ³digo
def p_nombre(p):
    """nombre : simbolo simbolo simbolo"""
    p[0] = Resultado
Por ejemplo:

python
Copiar cÃ³digo
def p_instruccion(p):
    """instruccion : USA ID PUNTO_Y_COMA
                   | SI PAREN_ABRE condicion PAREN_CIERRA LLAVE_ABRE lista_instrucciones LLAVE_CIERRA
                   | SI PAREN_ABRE condicion PAREN_CIERRA LLAVE_ABRE lista_instrucciones LLAVE_CIERRA SINO LLAVE_ABRE lista_instrucciones LLAVE_CIERRA"""
ğŸ”¹ Cada lÃ­nea dentro del docstring """ ... """ define una producciÃ³n posible para esa regla.
Por ejemplo:

usa puÃ±o_fuerte;

si (self.st > 50) { usa golpe; }

si (...) { ... } sino { ... }

ğŸ”¹ El parÃ¡metro p funciona como una lista de sÃ­mbolos, donde:

p[0] es el resultado (lo que se devuelve a la regla superior),

p[1], p[2], etc. son los elementos reconocidos (tokens o subreglas).

Ejemplo:

python
Copiar cÃ³digo
if len(p) == 4:
    p[0] = Usar(p[2])  # Construye un objeto de tipo Usar()
elif len(p) == 8:
    p[0] = SiSino(p[3], p[6], [])  # Condicional simple
else:
    p[0] = SiSino(p[3], p[6], p[10])  # Condicional con "sino"
3ï¸âƒ£ EjecuciÃ³n del combate
Se crean objetos de las clases definidas en gramatica.py (Luchador, Combo, CondiciÃ³n, etc.).

El intÃ©rprete recorre la simulaciÃ³n, turno por turno:

Aplica acciones (usa <acciÃ³n>).

EvalÃºa condiciones (si/sino).

Controla la energÃ­a (ST) y los puntos de vida (HP).

Aplica las reglas de fallo de combo (si no hay ST suficiente, se usa la primera acciÃ³n del combo).

ğŸ§© Ãrbol sintÃ¡ctico simplificado
Para la instrucciÃ³n:

txt
Copiar cÃ³digo
si (oponente.hp < 50) {
    usa Hadouken;
} sino {
    usa puÃ±o_fuerte;
}
El parser genera internamente:

less
Copiar cÃ³digo
SiSino(
  condicion = (oponente.hp < 50),
  bloque_si = [Usar("Hadouken")],
  bloque_sino = [Usar("puÃ±o_fuerte")]
)
ğŸ Resultado del combate (ejemplo)
yaml
Copiar cÃ³digo
âš”ï¸  COMBATE: Ryu vs Ken
Turnos mÃ¡ximos: 5

â¡ï¸  Turno 1 de Ryu:
ğŸ¥Š Ryu usa puÃ±o_fuerte (-10 HP al rival)
ğŸ¥Š Ryu usa patada_baja (-6 HP al rival)

â¡ï¸  Turno 1 de Ken:
ğŸ¥Š Ken usa puÃ±o_fuerte (-10 HP al rival)
ğŸ’¥ Ken ejecuta combo Hadouken
ğŸ¥Š Ken usa puÃ±o_fuerte (-10 HP al rival)
ğŸ¥Š Ken usa patada_baja (-6 HP al rival)

ğŸ RESULTADO FINAL:
Ryu: HP=74, ST=83
Ken: HP=84, ST=73
ğŸ”¥ Gana Ken
ğŸ§¾ ConclusiÃ³n
Este intÃ©rprete muestra el flujo completo de un mini lenguaje imperativo, desde el anÃ¡lisis lÃ©xico hasta la ejecuciÃ³n.
Permite comprender de forma prÃ¡ctica cÃ³mo funcionan:

Las gramÃ¡ticas libres de contexto,

Las estructuras condicionales simples,

Y la traducciÃ³n de reglas sintÃ¡cticas en objetos ejecutables.